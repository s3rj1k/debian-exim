Description: Fix CVE-2016-1531:
 All installations having Exim set-uid root and using 'perl_startup' are
 vulnerable to a local privilege escalation. Any user who can start an
 instance of Exim (and this is normally *any* user) can gain root
 privileges.

 New options
 -----------

 We had to introduce two new configuration options:

     keep_environment =
     add_environment =

 Both options are empty per default. That is, Exim cleans the complete
 environment on startup. This affects Exim itself and any subprocesses,
 as transports, that may call other programs via some alias mechanisms,
 as routers (queryprogram), lookups, and so on.

 ** THIS MAY BREAK your existing installation **

 If both options are not used in the configuration, Exim issues a warning
 on startup. This warning disappears if at least one of these options is
 used (even if set to an empty value).

 keep_environment should contain a list of trusted environment variables.
 (Do you trust PATH?). This may be a list of names and REs.

     keep_environment = ^LDAP_ : FOO_PATH

 To add (or override) variables, you can use add_environment:

     add_environment = <; PATH=/sbin:/usr/sbin


 New behaviour
 -------------

 Now Exim changes it's working directory to / right after startup,
 even before reading it's configuration. (Later Exim changes it's working
 directory to $spool_directory, as usual.)

 Exim only accepts an absolute configuration file path now, when using
 the -C option.
Origin: upstream

--- a/OS/Makefile-Base
+++ b/OS/Makefile-Base
@@ -313,6 +313,7 @@ OBJ_EXIM = acl.o child.o crypt16.o daemo
         rda.o readconf.o receive.o retry.o rewrite.o rfc2047.o \
         route.o search.o sieve.o smtp_in.o smtp_out.o spool_in.o spool_out.o \
         std-crypto.o store.o string.o tls.o tod.o transport.o tree.o verify.o \
+        environment.o \
         $(OBJ_LOOKUPS) \
         local_scan.o $(EXIM_PERL) $(OBJ_WITH_CONTENT_SCAN) \
         $(OBJ_WITH_OLD_DEMIME) $(OBJ_EXPERIMENTAL)
@@ -549,6 +550,7 @@ dns.o:           $(HDRS) dns.c
 enq.o:           $(HDRS) enq.c
 exim.o:          $(HDRS) exim.c
 expand.o:        $(HDRS) expand.c
+environment.o:   $(HDRS) environment.c
 filter.o:        $(HDRS) filter.c
 filtertest.o:    $(HDRS) filtertest.c
 globals.o:       $(HDRS) globals.c
--- a/doc/exim.8
+++ b/doc/exim.8
@@ -424,6 +424,10 @@ using one of the words \fBrouter_list\fP
 settings can be obtained by using \fBrouters\fP, \fBtransports\fP, or
 \fBauthenticators\fP.
 .sp
+If \fBenvironment\fP is given as an argument, the set of environment
+variables is output, line by line. Using the \fB\-n\fP flag supresses the value of the
+variables.
+.sp
 If invoked by an admin user, then \fBmacro\fP, \fBmacro_list\fP and \fBmacros\fP
 are available, similarly to the drivers.  Because macros are sometimes used
 for storing passwords, this option is restricted.
@@ -695,6 +699,8 @@ name, but it can be a colon\-separated l
 file that exists is used. Failure to open an existing file stops Exim from
 proceeding any further along the list, and an error is generated.
 .sp
+The file names need to be absolute names.
+.sp
 When this option is used by a caller other than root, and the list is different
 from the compiled\-in list, Exim gives up its root privilege immediately, and
 runs with the real and effective uid and gid set to those of the caller.
--- a/doc/spec.txt
+++ b/doc/spec.txt
@@ -3013,6 +3013,10 @@ brief message about itself and exits.
     authenticator_list, and a complete list of all drivers with their option
     settings can be obtained by using routers, transports, or authenticators.
 
+    If environment is given as an argument, the set of environment variables is
+    output, line by line. Using the -n flag supresses the value of the
+    variables.
+
     If invoked by an admin user, then macro, macro_list and macros are
     available, similarly to the drivers. Because macros are sometimes used for
     storing passwords, this option is restricted. The output format is one item
@@ -3301,6 +3305,8 @@ brief message about itself and exits.
     first file that exists is used. Failure to open an existing file stops Exim
     from proceeding any further along the list, and an error is generated.
 
+    The file names need to be absolute names.
+
     When this option is used by a caller other than root, and the list is
     different from the compiled-in list, Exim gives up its root privilege
     immediately, and runs with the real and effective uid and gid set to those
@@ -11964,6 +11970,14 @@ received. See chapter 42 for further det
 This option defines the ACL that is run when an SMTP VRFY command is received.
 See chapter 42 for further details.
 
++---------------+---------+-----------------+--------------+
+|add_environment|Use: main|Type: string list|Default: empty|
++---------------+---------+-----------------+--------------+
+
+This option allows to set individual environment variables that the currently
+linked libraries and programs in child processes use. The default list is
+empty,
+
 +------------+---------+------------------+--------------+
 |admin_groups|Use: main|Type: string list*|Default: unset|
 +------------+---------+------------------+--------------+
@@ -12973,6 +12987,29 @@ ignore_fromline_local must be set to ach
 
 See ignore_fromline_hosts above.
 
++----------------+---------+-----------------+--------------+
+|keep_environment|Use: main|Type: string list|Default: unset|
++----------------+---------+-----------------+--------------+
+
+This option contains a string list of environment variables to keep. You have
+to trust these variables or you have to be sure that these variables do not
+impose any security risk. Keep in mind that during the startup phase Exim is
+running with an effective UID 0 in most installations. As the default value is
+an empty list, the default environment for using libraries, running embedded
+Perl code, or running external binaries is empty, and does not not even contain
+PATH or HOME.
+
+Actually the list is interpreted as a list of patterns (10.1), except that it
+is not expanded first.
+
+WARNING: Macro substitution is still done first, so having a macro FOO and
+having FOO_HOME in your keep_environment option may have unexpected results.
+You may work around this using a regular expression that does not match the
+macro name: ^[F]OO_HOME$.
+
+Current versions of Exim issue a warning during startupif you do not mention 
+keep_environment or add_environment in your runtime configuration file.
+
 +--------------+---------+----------+-----------+
 |keep_malformed|Use: main|Type: time|Default: 4d|
 +--------------+---------+----------+-----------+
@@ -13978,6 +14015,14 @@ qualifies them only if the message came
 sender_unqualified_hosts, or if the message was submitted locally (not using
 TCP/IP), and the -bnq option was not set.
 
++---------------+---------+-----------------+--------------+
+|set_environment|Use: main|Type: string list|Default: empty|
++---------------+---------+-----------------+--------------+
+
+This option allows to set individual environment variables that the currently
+linked libraries and programs in child processes use. The default list is
+empty,
+
 +---------------------+---------+-------------+-------------+
 |smtp_accept_keepalive|Use: main|Type: boolean|Default: true|
 +---------------------+---------+-------------+-------------+
--- a/scripts/MakeLinks
+++ b/scripts/MakeLinks
@@ -197,6 +197,7 @@ ln -s ../src/dns.c             dns.c
 ln -s ../src/drtables.c        drtables.c
 ln -s ../src/dummies.c         dummies.c
 ln -s ../src/enq.c             enq.c
+ln -s ../src/environment.c     environment.c
 ln -s ../src/exim.c            exim.c
 ln -s ../src/exim_dbmbuild.c   exim_dbmbuild.c
 ln -s ../src/exim_dbutil.c     exim_dbutil.c
--- /dev/null
+++ b/src/environment.c
@@ -0,0 +1,71 @@
+/*************************************************
+*     Exim - an Internet mail transport agent    *
+*************************************************/
+
+/* Copyright (c) Heiko Schlittermann 2016
+ * hs@schlittermann.de
+ * See the file NOTICE for conditions of use and distribution.
+ */
+
+#include "exim.h"
+
+extern char **environ;
+
+/* The cleanup_environment() function is used during the startup phase
+of the Exim process, right after reading the configurations main
+part, before any expansions take place. It retains the environment
+variables we trust (via the keep_environment option) and allows to
+set additional variables (via add_environment).
+
+Returns:    TRUE if successful
+            FALSE otherwise
+*/
+
+BOOL
+cleanup_environment()
+{
+if (!keep_environment || *keep_environment == '\0')
+  {
+  /* From: https://github.com/dovecot/core/blob/master/src/lib/env-util.c#L55
+  Try to clear the environment.
+  a) environ = NULL crashes on OS X.
+  b) *environ = NULL doesn't work on FreeBSD 7.0.
+  c) environ = emptyenv doesn't work on Haiku OS
+  d) environ = calloc() should work everywhere */
+
+  if (environ) *environ = NULL;
+
+  }
+else if (Ustrcmp(keep_environment, "*") != 0)
+  {
+  uschar **p;
+  if (environ) for (p = USS environ; *p; /* see below */)
+    {
+    /* It's considered broken if we do not find the '=', according to
+    Florian Weimer. For now we ignore such strings. unsetenv() would complain,
+    getenv() would complain. */
+    uschar *eqp = Ustrchr(*p, '=');
+
+    if (eqp)
+      {
+      uschar *name = string_copyn(*p, eqp - *p);
+      if (OK != match_isinlist(name, USS &keep_environment,
+          0, NULL, NULL, MCL_NOEXPAND, FALSE, NULL))
+        if (unsetenv(CS name) < 0) return FALSE;
+        else p = USS environ; /* RESTART from the beginning */
+      else p++;
+      store_reset(name);
+      }
+    }
+  }
+if (add_environment)
+  {
+    uschar *p;
+    int sep = 0;
+    uschar* envlist = add_environment;
+    while ((p = string_nextinlist(&envlist, &sep, NULL, 0)))
+        putenv(CS p);
+  }
+
+  return TRUE;
+}
--- a/src/exim.c
+++ b/src/exim.c
@@ -3493,8 +3493,19 @@ init_lookup_list();
 is a failure. It leaves the configuration file open so that the subsequent
 configuration data for delivery can be read if needed. */
 
+/* To be safe: change the working directory to /. */
+if (Uchdir("/") < 0)
+  {
+    perror("exim: chdir `/': ");
+    exit(EXIT_FAILURE);
+  }
+
 readconf_main();
 
+if (cleanup_environment() == FALSE)
+  log_write(0, LOG_PANIC_DIE, "Can't cleanup environment");
+
+
 /* Handle the decoding of logging options. */
 
 decode_bits(&log_write_selector, &log_extra_selector, 0, 0,
@@ -3562,7 +3573,7 @@ TMPDIR macro, if this macro is defined.
 #ifdef TMPDIR
   {
   uschar **p;
-  for (p = USS environ; *p != NULL; p++)
+  if (environ) for (p = USS environ; *p != NULL; p++)
     {
     if (Ustrncmp(*p, "TMPDIR=", 7) == 0 &&
         Ustrcmp(*p+7, TMPDIR) != 0)
@@ -3602,10 +3613,10 @@ else
     uschar **new;
     uschar **newp;
     int count = 0;
-    while (*p++ != NULL) count++;
+    if (environ) while (*p++ != NULL) count++;
     if (envtz == NULL) count++;
     newp = new = malloc(sizeof(uschar *) * (count + 1));
-    for (p = USS environ; *p != NULL; p++)
+    if (environ) for (p = USS environ; *p != NULL; p++)
       {
       if (Ustrncmp(*p, "TZ=", 3) == 0) continue;
       *newp++ = *p;
@@ -4234,7 +4245,8 @@ if (list_options)
           (Ustrcmp(argv[i], "router") == 0 ||
            Ustrcmp(argv[i], "transport") == 0 ||
            Ustrcmp(argv[i], "authenticator") == 0 ||
-           Ustrcmp(argv[i], "macro") == 0))
+           Ustrcmp(argv[i], "macro") == 0 ||
+           Ustrcmp(argv[i], "environment") == 0))
         {
         readconf_print(argv[i+1], argv[i]);
         i++;
--- a/src/functions.h
+++ b/src/functions.h
@@ -70,7 +70,7 @@ extern int     check_host(void *, uschar
 extern uschar **child_exec_exim(int, BOOL, int *, BOOL, int, ...);
 extern pid_t   child_open_uid(uschar **, uschar **, int, uid_t *, gid_t *,
                  int *, int *, uschar *, BOOL);
-
+extern BOOL    cleanup_environment(void);
 extern void    daemon_go(void);
 
 #ifdef EXPERIMENTAL_DCC
@@ -325,6 +325,7 @@ extern int     stdin_ungetc(int);
 extern uschar *string_append(uschar *, int *, int *, int, ...);
 extern uschar *string_base62(unsigned long int);
 extern uschar *string_cat(uschar *, int *, int *, const uschar *, int);
+extern int     string_compare_by_pointer(const void *, const void *);
 extern uschar *string_copy_dnsdomain(uschar *);
 extern uschar *string_copy_malloc(uschar *);
 extern uschar *string_copylc(uschar *);
--- a/src/globals.c
+++ b/src/globals.c
@@ -256,6 +256,7 @@ uschar *acl_wherecodes[]       = { US"55
 BOOL    active_local_from_check = FALSE;
 BOOL    active_local_sender_retain = FALSE;
 BOOL    accept_8bitmime        = TRUE; /* deliberately not RFC compliant */
+uschar *add_environment        = NULL;
 address_item  *addr_duplicate  = NULL;
 
 address_item address_defaults = {
@@ -676,6 +677,8 @@ uschar *iterate_item           = NULL;
 
 int     journal_fd             = -1;
 
+uschar *keep_environment       = NULL;
+
 int     keep_malformed         = 4*24*60*60;    /* 4 days */
 
 uschar *eldap_dn               = NULL;
--- a/src/globals.h
+++ b/src/globals.h
@@ -131,6 +131,7 @@ extern uschar **address_expansions[ADDRE
 /* General global variables */
 
 extern BOOL    accept_8bitmime;        /* Allow *BITMIME incoming */
+extern uschar *add_environment;        /* List of environment variables to add */
 extern header_line *acl_added_headers; /* Headers added by an ACL */
 extern tree_node *acl_anchor;          /* Tree of named ACLs */
 extern uschar *acl_not_smtp;           /* ACL run for non-SMTP messages */
@@ -436,6 +437,7 @@ extern uschar *iterate_item;           /
 
 extern int     journal_fd;             /* Fd for journal file */
 
+extern uschar *keep_environment;       /* Whitelist for environment variables */
 extern int     keep_malformed;         /* Time to keep malformed messages */
 
 extern uschar *eldap_dn;               /* Where LDAP DNs are left */
--- a/src/mytypes.h
+++ b/src/mytypes.h
@@ -66,6 +66,7 @@ almost always literal strings. */
 #define US   (unsigned char *)
 #define CUS  (const unsigned char *)
 #define USS  (unsigned char **)
+#define CUSS (const unsigned char **)
 
 /* The C library string functions expect "char *" arguments. Use macros to
 avoid having to write a cast each time. We do this for string and file
--- a/src/readconf.c
+++ b/src/readconf.c
@@ -11,6 +11,9 @@ implementation of the conditional .ifdef
 
 #include "exim.h"
 
+extern char **environ;
+
+
 #define CSTATE_STACK_SIZE 10
 
 
@@ -159,6 +162,7 @@ static optionlist optionlist_config[] =
   { "acl_smtp_starttls",        opt_stringptr,   &acl_smtp_starttls },
 #endif
   { "acl_smtp_vrfy",            opt_stringptr,   &acl_smtp_vrfy },
+  { "add_environment",          opt_stringptr,   &add_environment },
   { "admin_groups",             opt_gidlist,     &admin_groups },
   { "allow_domain_literals",    opt_bool,        &allow_domain_literals },
   { "allow_mx_to_ip",           opt_bool,        &allow_mx_to_ip },
@@ -260,6 +264,7 @@ static optionlist optionlist_config[] =
   { "ignore_bounce_errors_after", opt_time,      &ignore_bounce_errors_after },
   { "ignore_fromline_hosts",    opt_stringptr,   &ignore_fromline_hosts },
   { "ignore_fromline_local",    opt_bool,        &ignore_fromline_local },
+  { "keep_environment",         opt_stringptr,   &keep_environment },
   { "keep_malformed",           opt_time,        &keep_malformed },
 #ifdef LOOKUP_LDAP
   { "ldap_ca_cert_dir",         opt_stringptr,   &eldap_ca_cert_dir },
@@ -2433,6 +2438,7 @@ second argument is NULL. There are some
   macro_list         print a list of macro names
   +name              print a named list item
   local_scan         print the local_scan options
+  environment        print the used execution environment
 
 If the second argument is not NULL, it must be one of "router", "transport",
 "authenticator" or "macro" in which case the first argument identifies the
@@ -2568,6 +2574,24 @@ if (type == NULL)
     names_only = TRUE;
     }
 
+  else if (Ustrcmp(name, "environment") == 0)
+    {
+    if (environ)
+      {
+      uschar **p;
+      size_t n;
+      for (p = USS environ; *p; p++) ;
+      n = p - USS environ;
+      qsort(environ, p - USS environ, sizeof(*p), string_compare_by_pointer);
+
+      for (p = USS environ; *p; p++)
+        {
+        puts(*p);
+        }
+      }
+    return;
+    }
+
   else
     {
     print_ol(find_option(name, optionlist_config, optionlist_config_size),
@@ -2881,6 +2905,15 @@ uschar *list = config_main_filelist;
 while((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))
        != NULL)
   {
+
+  /* To avoid confusion: Exim changes to / at the very beginning and
+   * and to $spool_directory later. */
+  if (filename[0] != '/')
+    {
+    fprintf(stderr, "-C %s: only absolute names are allowed\n", filename);
+    exit(EXIT_FAILURE);
+  }
+
   /* Cut out all the fancy processing unless specifically wanted */
 
   #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)
@@ -3316,8 +3349,12 @@ if (openssl_options != NULL)
 # endif
   }
 #endif
-}
 
+if ((!add_environment || *add_environment == '\0') && !keep_environment)
+  log_write(0, LOG_MAIN,
+      "WARNING: purging the environment.\n"
+      " Suggested action: use keep_environment and add_environment.\n");
+}
 
 
 /*************************************************
--- a/src/string.c
+++ b/src/string.c
@@ -1589,6 +1589,17 @@ return yield;
 #endif  /* COMPILE_UTILITY */
 
 
+#ifndef COMPILE_UTILITY
+/* qsort(3), currently used to sort the environment variables
+for -bP environment output, needs a function to compare two pointers to string
+pointers. Here it is. */
+
+int
+string_compare_by_pointer(const void *a, const void *b)
+{
+return Ustrcmp(* CUSS a, * CUSS b);
+}
+#endif /* COMPILE_UTILITY */
 
 
 
